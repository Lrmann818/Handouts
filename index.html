<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Campaign Tracker</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel2: #12141a;
      --text: #e7e7ea;
      --muted: #a7acb8;
      --border: #2a2f3a;
      --accent: #7aa2ff;
      --danger: #ff6b6b;
      --ok: #4cd4a3;
      --shadow: 0 8px 22px rgba(0,0,0,.35);
      --radius: 14px;
      --gap: 14px;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--font);
      background: radial-gradient(1100px 600px at 20% 0%, rgba(122,162,255,.10), transparent 60%),
                  radial-gradient(900px 500px at 85% 10%, rgba(76,212,163,.08), transparent 55%),
                  var(--bg);
      color: var(--text);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(15,17,21,.85);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px 14px 22px;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--gap);
      padding: 10px 0;
    }

    .title {
      display: flex;
      align-items: baseline;
      gap: 10px;
      flex-wrap: wrap;
    }
    .title h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: .2px;
    }
    .title .hint {
      color: var(--muted);
      font-size: 13px;
    }

    .btn {
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color: var(--text);
      padding: 9px 12px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: var(--shadow);
      font-weight: 600;
      font-size: 13px;
      user-select: none;
    }
    .btn:hover { border-color: rgba(122,162,255,.5); }
    .btn:active { transform: translateY(1px); }
    .btn.danger:hover { border-color: rgba(255,107,107,.55); }
    .btn.ok:hover { border-color: rgba(76,212,163,.55); }
    .btn:disabled { opacity: .55; cursor: not-allowed; transform: none; }

    input[type="file"] { display: none; }

    /* One-column layout in preferred order */
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
      margin-top: 14px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.14);
      gap: 10px;
      flex-wrap: wrap;
    }

    .card .head h2 {
      margin: 0;
      font-size: 14px;
      letter-spacing: .3px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .card .body { padding: 12px; }

    .muted { color: var(--muted); }

    /* Editable blocks */
    .editable {
      border: 1px dashed rgba(167,172,184,.25);
      border-radius: 12px;
      padding: 10px;
      min-height: 110px;
      outline: none;
      line-height: 1.35;
      background: rgba(0,0,0,.12);
    }
    .editable:focus {
      border-color: rgba(122,162,255,.55);
      box-shadow: 0 0 0 3px rgba(122,162,255,.12);
    }

    /* Map */
    .mapWrap {
      position: relative;
      width: 100%;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: var(--panel2);
    }
    .mapImg {
      width: 100%;
      display: block;
      user-select: none;
      pointer-events: none;
    }
    canvas {
      position: absolute;
      left: 0; top: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    .controlsRow {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .field {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,.12);
    }
    .field label { font-size: 12px; color: var(--muted); }
    .field input, .field select {
      background: transparent;
      border: none;
      outline: none;
      color: var(--text);
      font-weight: 700;
      width: 84px;
    }
    .field input::placeholder { color: rgba(167,172,184,.5); }
    .field .wide { width: 180px; font-weight: 600; }
    .field select { width: 160px; font-weight: 700; }

    .mini { font-size: 12px; color: var(--muted); }

    .pill {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.14);
    }

    .imgSlot {
      display: grid;
      grid-template-columns: 92px 1fr;
      gap: 12px;
      align-items: start;
    }

    .portrait {
      width: 92px;
      height: 92px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    .portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .linkList a { color: var(--accent); }
    .linkList a:hover { text-decoration: underline; }

    /* Characters Met dropdown + viewer */
    .charViewer {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px;
      background: rgba(0,0,0,.12);
      display: grid;
      grid-template-columns: 92px 1fr;
      gap: 12px;
      align-items: start;
      margin-top: 10px;
    }
    .charThumb {
      width: 92px;
      height: 92px;
      border-radius: 14px;
      border: 1px solid var(--border);
      overflow: hidden;
      background: rgba(0,0,0,.18);
      display: grid;
      place-items: center;
    }
    .charThumb img { width: 100%; height: 100%; object-fit: cover; display:block; }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1 contenteditable="true" id="campaignTitle">Campaign Tracker</h1>
        <span class="hint" id="syncHint">Firebase sync: off (fill config)</span>
      </div>
      <div class="row">
        <button class="btn ok" id="exportBtn" type="button">Export Backup</button>
        <label class="btn" for="importFile">Import Backup</label>
        <input id="importFile" type="file" accept="application/json" />
        <button class="btn danger" id="resetBtn" type="button">Reset Campaign</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <!-- 1) MAP -->
    <section class="card" id="mapCard">
      <div class="head">
        <h2>Map</h2>
        <div class="row">
          <label class="btn" for="mapFile">Upload Map</label>
          <input id="mapFile" type="file" accept="image/*" />
          <button class="btn danger" id="clearDraw" type="button">Clear Drawing</button>
        </div>
      </div>

      <div class="body">
        <div class="controlsRow">
          <div class="row">
            <span class="pill">Draw: <strong>finger / mouse</strong></span>
            <span class="pill">Eraser: <strong>toggle</strong></span>
            <span class="pill">Sync: <strong>realtime</strong></span>
          </div>

          <div class="row">
            <button class="btn" id="eraserBtn" type="button">Eraser: Off</button>

            <span class="field">
              <label for="brushSize">Brush</label>
              <input id="brushSize" type="number" min="1" max="40" value="6" />
            </span>
          </div>
        </div>

        <div class="mapWrap" id="mapWrap">
          <img class="mapImg" id="mapImg" alt="Map" />
          <canvas id="drawCanvas"></canvas>
        </div>

        <p class="mini" style="margin:10px 0 0;">
          Tip: Use <b>?c=campaignName</b> in the URL to switch campaigns.
        </p>
      </div>
    </section>

    <!-- 2) CURRENT ENEMY / NPC / ENVIRONMENT -->
    <section class="card" id="enemyCard">
      <div class="head">
        <h2>Current Enemy / NPC / Environment</h2>
        <span class="mini muted">Synced for everyone</span>
      </div>
      <div class="body">
        <div class="imgSlot">
          <div class="portrait">
            <img id="enemyImg" alt="" style="display:none;" />
            <span id="enemyImgHint" class="mini">No image</span>
          </div>
          <div>
            <div class="row" style="justify-content: space-between;">
              <label class="btn" for="enemyFile">Set Image</label>
              <input id="enemyFile" type="file" accept="image/*" />
              <button class="btn danger" id="enemyClearImg" type="button">Remove</button>
            </div>

            <div class="row" style="margin-top: 10px; gap: 10px;">
              <span class="field">
                <label>Name</label>
                <input class="wide" id="enemyName" placeholder="Swamp Horror / Rival / Trap…" />
              </span>

              <span class="field">
                <label>HP</label>
                <input id="enemyHp" placeholder="HP" />
              </span>

              <span class="field">
                <label>Status</label>
                <input class="wide" id="enemyStatus" placeholder="Restrained, burning, etc." />
              </span>
            </div>

            <div class="editable" id="enemyNotes" contenteditable="true" style="margin-top: 10px;">
              <b>Notes:</b> tactics, resistances, terrain effects, dialogue, etc.
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 3) PARTY STATUS -->
    <section class="card" id="partyCard">
      <div class="head">
        <h2>Party Status</h2>
        <span class="mini muted">Synced for everyone (edit your HP/status)</span>
      </div>
      <div class="body">
        <div class="imgSlot" style="margin-bottom: 12px;">
          <div class="portrait">
            <img id="partyImg" alt="" style="display:none;" />
            <span id="partyImgHint" class="mini">No image</span>
          </div>
          <div>
            <div class="row" style="justify-content: space-between;">
              <label class="btn" for="partyFile">Set Party Image</label>
              <input id="partyFile" type="file" accept="image/*" />
              <button class="btn danger" id="partyClearImg" type="button">Remove</button>
            </div>
            <div class="mini muted" style="margin-top:8px;">
              Use this image slot for a party group shot, party logo, or initiative order screenshot.
            </div>
          </div>
        </div>

        <div class="row" style="margin-bottom: 10px;">
          <span class="pill">Quick fields</span>
          <span class="mini muted" id="partySyncStatus"></span>
        </div>

        <div style="display:grid; gap: 10px;">
          <div class="field" style="justify-content: space-between; width: 100%;">
            <label>Character 1</label>
            <input class="wide" id="p1Name" placeholder="Name" />
            <input id="p1Hp" placeholder="HP" />
            <input class="wide" id="p1Status" placeholder="Status (poisoned, bless…)" />
          </div>

          <div class="field" style="justify-content: space-between; width: 100%;">
            <label>Character 2</label>
            <input class="wide" id="p2Name" placeholder="Name" />
            <input id="p2Hp" placeholder="HP" />
            <input class="wide" id="p2Status" placeholder="Status" />
          </div>

          <div class="field" style="justify-content: space-between; width: 100%;">
            <label>Character 3</label>
            <input class="wide" id="p3Name" placeholder="Name" />
            <input id="p3Hp" placeholder="HP" />
            <input class="wide" id="p3Status" placeholder="Status" />
          </div>

          <div class="field" style="justify-content: space-between; width: 100%;">
            <label>Character 4</label>
            <input class="wide" id="p4Name" placeholder="Name" />
            <input id="p4Hp" placeholder="HP" />
            <input class="wide" id="p4Status" placeholder="Status" />
          </div>
        </div>

        <div style="margin-top: 12px;" class="editable" id="partyNotes" contenteditable="true">
          <b>Party notes:</b> initiative, resources, clues, reminders…
        </div>
      </div>
    </section>

    <!-- 4) CHARACTERS MET -->
    <section class="card" id="charactersMetCard">
      <div class="head">
        <h2>Characters Met</h2>
        <div class="row">
          <button class="btn ok" id="addCharBtn" type="button">Add Character</button>
        </div>
      </div>

      <div class="body">
        <div class="row" style="justify-content: space-between;">
          <span class="mini muted">Select a character to view/edit. Everyone shares the same list.</span>
          <span class="mini muted" id="charSyncStatus"></span>
        </div>

        <div class="row" style="margin-top:10px;">
          <span class="field" style="width:100%;">
            <label>Character</label>
            <select id="charSelect" style="flex:1; min-width: 240px;">
              <option value="">(none)</option>
            </select>
          </span>
        </div>

        <div id="charViewer" class="charViewer" style="display:none;">
          <div class="charThumb">
            <img id="charViewImg" alt="" style="display:none;" />
            <span id="charViewImgHint" class="mini">No image</span>
          </div>
          <div>
            <div class="row" style="justify-content: space-between;">
              <b id="charViewName">—</b>
              <div class="row">
                <button class="btn" id="editCharBtn" type="button">Edit</button>
                <button class="btn danger" id="deleteCharBtn" type="button">Delete</button>
              </div>
            </div>

            <div class="row" style="margin-top:10px;">
              <span class="field">
                <label>Group</label>
                <select id="charFaction">
                  <option value="friendly">Friendlies</option>
                  <option value="foe">Foes</option>
                  <option value="undecided">Undecideds</option>
                </select>
              </span>
            </div>

            <div style="margin-top:10px;" id="charViewDesc" class="editable" contenteditable="false"></div>
          </div>
        </div>

        <div class="card" style="margin-top:12px; border-radius:12px;" id="charFormCard">
          <div class="body" style="display:grid; gap:10px;">
            <div class="row" style="justify-content: space-between;">
              <b id="charFormTitle">Add Character</b>
              <button class="btn danger" id="cancelCharBtn" type="button">Cancel</button>
            </div>

            <div class="row" style="gap:10px; flex-wrap:wrap;">
              <span class="field">
                <label>Name</label>
                <input class="wide" id="charName" placeholder="Name" />
              </span>

              <span class="field">
                <label>Group</label>
                <select id="charFactionEdit">
                  <option value="friendly">Friendlies</option>
                  <option value="foe">Foes</option>
                  <option value="undecided">Undecideds</option>
                </select>
              </span>
            </div>

            <div>
              <div class="mini muted" style="margin-bottom:6px;">Description</div>
              <div class="editable" id="charDesc" contenteditable="true" style="min-height:90px;"></div>
            </div>

            <div class="row" style="justify-content: space-between;">
              <label class="btn" for="charImgFile">Choose Image</label>
              <input id="charImgFile" type="file" accept="image/*" />
              <span class="mini muted" id="charImgStatus">No file selected</span>
            </div>

            <div class="row" style="justify-content:flex-end;">
              <button class="btn ok" id="saveCharBtn" type="button">Save</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 5) LINKS -->
    <section class="card" id="linksCard">
      <div class="head">
        <h2>Puzzle / Handout Links</h2>
        <span class="mini muted">Synced for everyone</span>
      </div>
      <div class="body">
        <div class="editable linkList" id="linksText" contenteditable="true">
          <b>Example:</b><br/>
          • <a href="https://example.com" target="_blank" rel="noreferrer">Puzzle 1</a><br/>
          • <a href="https://example.com" target="_blank" rel="noreferrer">Cipher Handout</a>
        </div>
      </div>
    </section>
  </div>
</main>

<script type="module">
const firebaseConfig = {
  apiKey: "AIzaSyCEWXwsYxrP75beNvGZTyVZWT0JKhZV2aw",
  authDomain: "dndcampaigntracker-d2824.firebaseapp.com",
  projectId: "dndcampaigntracker-d2824",
  storageBucket: "dndcampaigntracker-d2824.firebasestorage.app",
  messagingSenderId: "746590357376",
  appId: "1:746590357376:web:1bd7b45b4d65af449ce365"
};

  const el = (id) => document.getElementById(id);
  const syncHint = el("syncHint");

  function isFirebaseConfigFilled(cfg) {
    return cfg
      && typeof cfg.apiKey === "string" && !cfg.apiKey.startsWith("YOUR_")
      && typeof cfg.projectId === "string" && !cfg.projectId.startsWith("YOUR_")
      && typeof cfg.storageBucket === "string" && !cfg.storageBucket.startsWith("YOUR_");
  }

  function disableAll(reason) {
    syncHint.textContent = reason;
    document.querySelectorAll("button, input, select, [contenteditable]").forEach(n => {
      if (n.id === "importFile") return;
      if (n.getAttribute("contenteditable") === "true") n.setAttribute("contenteditable", "false");
      if (n.tagName === "BUTTON") n.disabled = true;
      if (n.tagName === "INPUT" || n.tagName === "SELECT") n.disabled = true;
    });
  }

  if (!isFirebaseConfigFilled(firebaseConfig)) {
    disableAll("Firebase sync: off (fill firebaseConfig at bottom of file)");
    throw new Error("Firebase config not filled.");
  }

  const { initializeApp } = await import("https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js");
  const { getAuth, signInAnonymously, onAuthStateChanged } = await import("https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js");
  const {
    getFirestore, collection, doc, setDoc, addDoc, updateDoc, deleteDoc, getDoc, getDocs,
    onSnapshot, serverTimestamp, query, orderBy, increment
  } = await import("https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js");
  const { getStorage, ref: sRef, uploadBytes, getDownloadURL } =
    await import("https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js");

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const storage = getStorage(app);

  await signInAnonymously(auth);

  let myUid = null;
  onAuthStateChanged(auth, (user) => { myUid = user?.uid ?? null; });

  const url = new URL(location.href);
  const campaignId = (url.searchParams.get("c") || "main").trim() || "main";
  syncHint.textContent = `Firebase sync: ON (campaign "${campaignId}")`;

  const campaignRef = doc(db, "campaigns", campaignId);
  const stateRef = doc(db, "campaigns", campaignId, "state", "main");
  const charsCol = collection(db, "campaigns", campaignId, "characters");
  const strokesCol = collection(db, "campaigns", campaignId, "mapStrokes");

  await setDoc(campaignRef, { updatedAt: serverTimestamp() }, { merge: true });

  const defaults = {
    title: "Campaign Tracker",
    linksHtml: "",
    partyNotesHtml: "",
    enemyNotesHtml: "",
    party: {
      p1Name:"", p1Hp:"", p1Status:"",
      p2Name:"", p2Hp:"", p2Status:"",
      p3Name:"", p3Hp:"", p3Status:"",
      p4Name:"", p4Hp:"", p4Status:""
    },
    enemy: { name:"", hp:"", status:"" },
    images: { mapUrl:null, partyUrl:null, enemyUrl:null },
    mapClearVersion: 0,
    updatedAt: null
  };

  const existing = await getDoc(stateRef);
  if (!existing.exists()) await setDoc(stateRef, { ...defaults, updatedAt: serverTimestamp() }, { merge: false });
  else {
    // State doc already exists; do NOT merge defaults here (it would overwrite saved data).
  }
const campaignTitle = el("campaignTitle");
  const linksText = el("linksText");

  const partySyncStatus = el("partySyncStatus");
  const partyNotes = el("partyNotes");
  const partyFields = [
    "p1Name","p1Hp","p1Status",
    "p2Name","p2Hp","p2Status",
    "p3Name","p3Hp","p3Status",
    "p4Name","p4Hp","p4Status"
  ].map(el);
  const partyFile = el("partyFile");
  const partyImg = el("partyImg");
  const partyImgHint = el("partyImgHint");
  el("partyClearImg").addEventListener("click", () => setImageUrl("partyUrl", null));

  const enemyNotes = el("enemyNotes");
  const enemyName = el("enemyName");
  const enemyHp = el("enemyHp");
  const enemyStatus = el("enemyStatus");
  const enemyFile = el("enemyFile");
  const enemyImg = el("enemyImg");
  const enemyImgHint = el("enemyImgHint");
  el("enemyClearImg").addEventListener("click", () => setImageUrl("enemyUrl", null));

  const mapFile = el("mapFile");
  const mapImg = el("mapImg");
  const mapWrap = el("mapWrap");
  const canvas = el("drawCanvas");
  const ctx = canvas.getContext("2d");
  const brushSize = el("brushSize");
  const eraserBtn = el("eraserBtn");
  const clearDrawBtn = el("clearDraw");

  const charSyncStatus = el("charSyncStatus");
  const addCharBtn = el("addCharBtn");
  const charSelect = el("charSelect");
  const charViewer = el("charViewer");
  const charViewImg = el("charViewImg");
  const charViewImgHint = el("charViewImgHint");
  const charViewName = el("charViewName");
  const charViewDesc = el("charViewDesc");
  const charFaction = el("charFaction");
  const editCharBtn = el("editCharBtn");
  const deleteCharBtn = el("deleteCharBtn");

  const charFormCard = el("charFormCard");
  const charFormTitle = el("charFormTitle");
  const cancelCharBtn = el("cancelCharBtn");
  const saveCharBtn = el("saveCharBtn");
  const charName = el("charName");
  const charFactionEdit = el("charFactionEdit");
  const charDesc = el("charDesc");
  const charImgFile = el("charImgFile");
  const charImgStatus = el("charImgStatus");

  const exportBtn = el("exportBtn");
  const importFile = el("importFile");
  const resetBtn = el("resetBtn");


  // --- Prevent cursor jump: don't re-render fields while the user is editing them ---
  const __editing = new Set();

  function __markEditing(node) {
    if (!node || !node.id) return;
    node.addEventListener("focus", () => __editing.add(node.id));
    node.addEventListener("blur", () => __editing.delete(node.id));
    // Mobile friendliness: some browsers don't fire focus the same way for contenteditable
    node.addEventListener("pointerdown", () => __editing.add(node.id));
    node.addEventListener("pointerup", () => setTimeout(() => {
      // if focus moved away, clear it
      if (document.activeElement !== node) __editing.delete(node.id);
    }, 0));
  }

  function __isEditing(node) {
    return !!(node && node.id && __editing.has(node.id));
  }

  [
    campaignTitle,
    linksText,
    partyNotes,
    enemyNotes,
    enemyName,
    enemyHp,
    enemyStatus,
    ...partyFields
  ].forEach(__markEditing);


  function debounce(fn, ms) {
    let t = null;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }

  function factionLabel(f) {
    if (f === "friendly") return "Friendlies";
    if (f === "foe") return "Foes";
    return "Undecideds";
  }

  async function uploadToStorage(path, fileOrBlob, contentType) {
    const fileRef = sRef(storage, path);
    const metadata = contentType ? { contentType } : undefined;
    await uploadBytes(fileRef, fileOrBlob, metadata);
    return await getDownloadURL(fileRef);
  }

  function setPortrait(imgEl, hintEl, url) {
    if (!url) {
      imgEl.style.display = "none";
      imgEl.removeAttribute("src");
      if (hintEl?.style) hintEl.style.display = "block";
      return;
    }
    imgEl.src = url;
    imgEl.style.display = "block";
    if (hintEl?.style) hintEl.style.display = "none";
  }

  async function setImageUrl(whichKey, url) {
    await updateDoc(stateRef, { [`images.${whichKey}`]: url, updatedAt: serverTimestamp() });
  }

  let suppressUIWrite = false;
  let currentClearVersion = 0;

  onSnapshot(stateRef, (snap) => {
    const s = snap.data();
    if (!s) return;

    suppressUIWrite = true;

    if (!__isEditing(campaignTitle)) {
      const nextTitle = s.title ?? defaults.title;
      if (campaignTitle.innerText !== nextTitle) campaignTitle.innerText = nextTitle;
    }
    if (!__isEditing(linksText)) {
      const nextLinks = typeof s.linksHtml === "string" ? s.linksHtml : "";
      if (linksText.innerHTML !== nextLinks) linksText.innerHTML = nextLinks;
    }

    const party = s.party || {};
    partyFields.forEach(inp => {
      if (__isEditing(inp)) return;
      const nextVal = party[inp.id] ?? "";
      if (inp.value !== nextVal) inp.value = nextVal;
    });
    if (!__isEditing(partyNotes)) {
      const nextPartyNotes = typeof s.partyNotesHtml === "string" ? s.partyNotesHtml : "";
      if (partyNotes.innerHTML !== nextPartyNotes) partyNotes.innerHTML = nextPartyNotes;
    }

    const enemy = s.enemy || {};
    if (!__isEditing(enemyName)) {
      const nextEnemyName = enemy.name ?? "";
      if (enemyName.value !== nextEnemyName) enemyName.value = nextEnemyName;
    }
    if (!__isEditing(enemyHp)) {
      const nextEnemyHp = enemy.hp ?? "";
      if (enemyHp.value !== nextEnemyHp) enemyHp.value = nextEnemyHp;
    }
    if (!__isEditing(enemyStatus)) {
      const nextEnemyStatus = enemy.status ?? "";
      if (enemyStatus.value !== nextEnemyStatus) enemyStatus.value = nextEnemyStatus;
    }
    if (!__isEditing(enemyNotes)) {
      const nextEnemyNotes = typeof s.enemyNotesHtml === "string" ? s.enemyNotesHtml : "";
      if (enemyNotes.innerHTML !== nextEnemyNotes) enemyNotes.innerHTML = nextEnemyNotes;
    }

    setPortrait(mapImg, null, s.images?.mapUrl ?? null);
    setPortrait(partyImg, partyImgHint, s.images?.partyUrl ?? null);
    setPortrait(enemyImg, enemyImgHint, s.images?.enemyUrl ?? null);

    const newV = Number.isFinite(s.mapClearVersion) ? s.mapClearVersion : 0;
    if (newV !== currentClearVersion) {
      currentClearVersion = newV;
      clearCanvas();
      renderedStrokeIds.clear();
      strokesById.clear();
      redrawAllStrokes();
    }

    suppressUIWrite = false;

    requestAnimationFrame(() => {
      setCanvasSizeToMatchDisplayed();
      redrawAllStrokes();
    });
  });

  const writeStateDebounced = debounce(async (patch) => {
    await updateDoc(stateRef, { ...patch, updatedAt: serverTimestamp() });
  }, 220);

  campaignTitle.addEventListener("input", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ title: campaignTitle.innerText.trim() });
  });
  campaignTitle.addEventListener("blur", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ title: campaignTitle.innerText.trim() });
  });

  linksText.addEventListener("input", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ linksHtml: linksText.innerHTML });
  });
  linksText.addEventListener("blur", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ linksHtml: linksText.innerHTML });
  });

  partyNotes.addEventListener("input", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ partyNotesHtml: partyNotes.innerHTML });
  });
  partyNotes.addEventListener("blur", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ partyNotesHtml: partyNotes.innerHTML });
  });

  enemyNotes.addEventListener("input", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ enemyNotesHtml: enemyNotes.innerHTML });
  });
  enemyNotes.addEventListener("blur", () => {
    if (suppressUIWrite) return;
    writeStateDebounced({ enemyNotesHtml: enemyNotes.innerHTML });
  });

  [enemyName, enemyHp, enemyStatus].forEach(inp => {
    const fn = () => {
      if (suppressUIWrite) return;
      writeStateDebounced({ enemy: { name: enemyName.value, hp: enemyHp.value, status: enemyStatus.value } });
    };
    inp.addEventListener("input", fn);
    inp.addEventListener("change", fn);
  });

  partyFields.forEach(inp => {
    const fn = () => {
      if (suppressUIWrite) return;
      const party = Object.fromEntries(partyFields.map(i => [i.id, i.value]));
      writeStateDebounced({ party });
      partySyncStatus.textContent = "saving…";
      setTimeout(() => (partySyncStatus.textContent = ""), 450);
    };
    inp.addEventListener("input", fn);
    inp.addEventListener("change", fn);
  });

  mapFile.addEventListener("change", async () => {
    const file = mapFile.files?.[0];
    if (!file) return;
    const path = `campaigns/${campaignId}/images/map-${Date.now()}-${file.name}`;
    const url = await uploadToStorage(path, file, file.type);
    await updateDoc(stateRef, { "images.mapUrl": url, updatedAt: serverTimestamp() });
    mapFile.value = "";
  });

  partyFile.addEventListener("change", async () => {
    const file = partyFile.files?.[0];
    if (!file) return;
    const path = `campaigns/${campaignId}/images/party-${Date.now()}-${file.name}`;
    const url = await uploadToStorage(path, file, file.type);
    await updateDoc(stateRef, { "images.partyUrl": url, updatedAt: serverTimestamp() });
    partyFile.value = "";
  });

  enemyFile.addEventListener("change", async () => {
    const file = enemyFile.files?.[0];
    if (!file) return;
    const path = `campaigns/${campaignId}/images/enemy-${Date.now()}-${file.name}`;
    const url = await uploadToStorage(path, file, file.type);
    await updateDoc(stateRef, { "images.enemyUrl": url, updatedAt: serverTimestamp() });
    enemyFile.value = "";
  });

  // MAP STROKES
  let eraser = false;
  eraserBtn.addEventListener("click", () => {
    eraser = !eraser;
    eraserBtn.textContent = "Eraser: " + (eraser ? "On" : "Off");
  });

  function setCanvasSizeToMatchDisplayed() {
    const rect = mapWrap.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function getPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const touch = evt.touches?.[0];
    const clientX = touch ? touch.clientX : evt.clientX;
    const clientY = touch ? touch.clientY : evt.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function clamp(n, a, b) { return Math.min(b, Math.max(a, n)); }

  const strokesById = new Map();
  const renderedStrokeIds = new Set();

  function drawStroke(stroke) {
    if (!stroke || stroke.v !== currentClearVersion) return;
    const pts = stroke.pts || [];
    if (pts.length < 2) return;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = clamp(parseInt(stroke.size || "6", 10), 1, 40);

    if (stroke.mode === "erase") {
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = "rgba(255,255,255,.9)";
    }

    const w = mapWrap.clientWidth;
    const h = mapWrap.clientHeight;

    ctx.beginPath();
    ctx.moveTo(pts[0].x * w, pts[0].y * h);
    for (let i = 1; i < pts.length; i++) {
      ctx.lineTo(pts[i].x * w, pts[i].y * h);
    }
    ctx.stroke();
  }

  function redrawAllStrokes() {
    clearCanvas();
    for (const stroke of strokesById.values()) {
      if (stroke.v === currentClearVersion) drawStroke(stroke);
    }
  }

  const strokesQ = query(strokesCol, orderBy("createdAt", "asc"));
  onSnapshot(strokesQ, (snap) => {
    snap.docChanges().forEach((ch) => {
      const id = ch.doc.id;
      if (ch.type === "removed") {
        strokesById.delete(id);
        renderedStrokeIds.delete(id);
        redrawAllStrokes();
        return;
      }

      const data = ch.doc.data();
      const stroke = {
        id,
        v: Number.isFinite(data.v) ? data.v : 0,
        pts: Array.isArray(data.pts) ? data.pts : [],
        size: data.size ?? 6,
        mode: data.mode ?? "draw",
        createdAt: data.createdAt ?? null,
        uid: data.uid ?? null
      };

      strokesById.set(id, stroke);

      if (stroke.v === currentClearVersion && !renderedStrokeIds.has(id)) {
        drawStroke(stroke);
        renderedStrokeIds.add(id);
      }
    });
  });

  let drawing = false;
  let strokePts = [];

  function startDraw(evt) {
    if (!mapImg.src) return;
    drawing = true;
    strokePts = [];
    const p = getPos(evt);
    const w = mapWrap.clientWidth, h = mapWrap.clientHeight;
    strokePts.push({ x: p.x / w, y: p.y / h });
    evt.preventDefault();
  }

  function moveDraw(evt) {
    if (!drawing) return;
    const p = getPos(evt);
    const w = mapWrap.clientWidth, h = mapWrap.clientHeight;
    const norm = { x: p.x / w, y: p.y / h };

    const last = strokePts[strokePts.length - 1];
    const dx = (norm.x - last.x) * w;
    const dy = (norm.y - last.y) * h;
    if ((dx*dx + dy*dy) < 9) return;

    strokePts.push(norm);

    // local preview
    drawStroke({
      v: currentClearVersion,
      pts: strokePts.slice(-2),
      size: brushSize.value,
      mode: eraser ? "erase" : "draw"
    });

    evt.preventDefault();
  }

  async function endDraw(evt) {
    if (!drawing) return;
    drawing = false;

    if (strokePts.length >= 2) {
      await addDoc(strokesCol, {
        v: currentClearVersion,
        pts: strokePts,
        size: clamp(parseInt(brushSize.value || "6", 10), 1, 40),
        mode: eraser ? "erase" : "draw",
        uid: myUid,
        createdAt: serverTimestamp()
      });
    }
    strokePts = [];
    evt?.preventDefault?.();
  }

  canvas.addEventListener("pointerdown", startDraw);
  canvas.addEventListener("pointermove", moveDraw);
  canvas.addEventListener("pointerup", endDraw);
  canvas.addEventListener("pointercancel", endDraw);
  canvas.addEventListener("touchstart", startDraw, { passive: false });
  canvas.addEventListener("touchmove", moveDraw, { passive: false });
  canvas.addEventListener("touchend", endDraw, { passive: false });

  clearDrawBtn.addEventListener("click", async () => {
    await updateDoc(stateRef, { mapClearVersion: increment(1), updatedAt: serverTimestamp() });
  });

  window.addEventListener("resize", () => {
    setCanvasSizeToMatchDisplayed();
    redrawAllStrokes();
  });

  // CHARACTERS MET
  const CHAR_SEL_KEY = `campaignTracker.charSelected.${campaignId}`;

  function hideCharForm() { charFormCard.style.display = "none"; }
  function openCharForm(mode, data = null) {
    charFormCard.style.display = "block";
    charFormTitle.textContent = mode === "edit" ? "Edit Character" : "Add Character";
    editingId = mode === "edit" ? data.id : null;

    charName.value = data?.name ?? "";
    charFactionEdit.value = data?.faction ?? "undecided";
    charDesc.innerHTML = data?.descHtml ?? "";
    charImgFile.value = "";
    pendingFile = null;
    charImgStatus.textContent = "No file selected";
  }
  function closeCharForm() {
    editingId = null;
    pendingFile = null;
    charName.value = "";
    charFactionEdit.value = "undecided";
    charDesc.innerHTML = "";
    charImgFile.value = "";
    charImgStatus.textContent = "No file selected";
    hideCharForm();
  }
  hideCharForm();

  let editingId = null;
  let pendingFile = null;

  addCharBtn.addEventListener("click", () => openCharForm("add"));
  cancelCharBtn.addEventListener("click", closeCharForm);

  charImgFile.addEventListener("change", () => {
    pendingFile = charImgFile.files?.[0] ?? null;
    charImgStatus.textContent = pendingFile ? pendingFile.name : "No file selected";
  });

  async function uploadCharacterImage(file, charId) {
    const path = `campaigns/${campaignId}/characters/${charId}-${Date.now()}-${file.name}`;
    return await uploadToStorage(path, file, file.type);
  }

  saveCharBtn.addEventListener("click", async () => {
    const name = charName.value.trim();
    const descHtml = charDesc.innerHTML.trim();
    const faction = charFactionEdit.value || "undecided";
    if (!name) { alert("Name is required."); return; }

    if (!editingId) {
      const newDoc = await addDoc(charsCol, { name, descHtml, faction, imageUrl: null, createdAt: serverTimestamp(), updatedAt: serverTimestamp() });
      if (pendingFile) {
        const url = await uploadCharacterImage(pendingFile, newDoc.id);
        await updateDoc(doc(charsCol, newDoc.id), { imageUrl: url, updatedAt: serverTimestamp() });
      }
      localStorage.setItem(CHAR_SEL_KEY, newDoc.id);
      closeCharForm();
      return;
    }

    const patch = { name, descHtml, faction, updatedAt: serverTimestamp() };
    if (pendingFile) patch.imageUrl = await uploadCharacterImage(pendingFile, editingId);
    await updateDoc(doc(charsCol, editingId), patch);
    closeCharForm();
  });

  const charsById = new Map();

  function buildDropdown() {
    const selected = localStorage.getItem(CHAR_SEL_KEY) || "";
    const groups = { friendly: [], foe: [], undecided: [] };
    for (const c of charsById.values()) (groups[c.faction] ?? groups.undecided).push(c);
    for (const k of Object.keys(groups)) groups[k].sort((a,b) => a.name.localeCompare(b.name));

    charSelect.innerHTML = `<option value="">(none)</option>`;
    for (const faction of ["friendly","foe","undecided"]) {
      const arr = groups[faction];
      if (!arr.length) continue;
      const og = document.createElement("optgroup");
      og.label = factionLabel(faction);
      arr.forEach(c => {
        const opt = document.createElement("option");
        opt.value = c.id;
        opt.textContent = c.name;
        og.appendChild(opt);
      });
      charSelect.appendChild(og);
    }

    if (selected && charsById.has(selected)) {
      charSelect.value = selected;
      showCharacter(selected);
    } else {
      charSelect.value = "";
      hideCharacter();
    }
  }

  function hideCharacter() {
    charViewer.style.display = "none";
    setPortrait(charViewImg, charViewImgHint, null);
    charViewName.textContent = "—";
    charViewDesc.innerHTML = "";
    currentViewedCharId = null;
  }

  let currentViewedCharId = null;
  function showCharacter(id) {
    const c = charsById.get(id);
    if (!c) { hideCharacter(); return; }
    currentViewedCharId = id;
    charViewer.style.display = "grid";
    setPortrait(charViewImg, charViewImgHint, c.imageUrl);
    charViewName.textContent = c.name;
    charViewDesc.innerHTML = c.descHtml || `<span class="mini muted">No description</span>`;
    charFaction.value = c.faction || "undecided";
  }

  charSelect.addEventListener("change", () => {
    const id = charSelect.value;
    if (!id) {
      localStorage.removeItem(CHAR_SEL_KEY);
      hideCharacter();
      return;
    }
    localStorage.setItem(CHAR_SEL_KEY, id);
    showCharacter(id);
  });

  charFaction.addEventListener("change", async () => {
    if (!currentViewedCharId) return;
    await updateDoc(doc(charsCol, currentViewedCharId), { faction: charFaction.value, updatedAt: serverTimestamp() });
  });

  editCharBtn.addEventListener("click", () => {
    if (!currentViewedCharId) return;
    const c = charsById.get(currentViewedCharId);
    if (!c) return;
    openCharForm("edit", c);
  });

  deleteCharBtn.addEventListener("click", async () => {
    if (!currentViewedCharId) return;
    const c = charsById.get(currentViewedCharId);
    if (!c) return;
    if (!confirm(`Delete ${c.name}?`)) return;
    await deleteDoc(doc(charsCol, currentViewedCharId));
    localStorage.removeItem(CHAR_SEL_KEY);
    hideCharacter();
  });

  const charsQ = query(charsCol, orderBy("createdAt", "asc"));
  onSnapshot(charsQ, (snap) => {
    charSyncStatus.textContent = `(${snap.size} saved)`;
    snap.docChanges().forEach((ch) => {
      const id = ch.doc.id;
      if (ch.type === "removed") { charsById.delete(id); return; }
      const d = ch.doc.data();
      charsById.set(id, { id, name: d.name ?? "", descHtml: d.descHtml ?? "", imageUrl: d.imageUrl ?? null, faction: d.faction ?? "undecided" });
    });
    buildDropdown();
    const sel = charSelect.value || localStorage.getItem(CHAR_SEL_KEY);
    if (sel && charsById.has(sel)) showCharacter(sel);
  });

  // BACKUP
  exportBtn.addEventListener("click", async () => {
    const stateSnap = await getDoc(stateRef);
    const state = stateSnap.data();
    const charsSnap = await getDocs(charsCol);
    const chars = charsSnap.docs.map(d => ({ id: d.id, ...d.data() }));
    const strokesSnap = await getDocs(strokesCol);
    const v = state?.mapClearVersion ?? 0;
    const strokes = strokesSnap.docs.map(d => ({ id: d.id, ...d.data() })).filter(s => (s.v ?? 0) === v);

    const backup = { campaignId, state, characters: chars, strokesCurrentVersion: strokes };
    const blob = new Blob([JSON.stringify(backup, null, 2)], { type: "application/json" });
    const u = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = u;
    a.download = `campaign-${campaignId}-backup.json`;
    a.click();
    URL.revokeObjectURL(u);
  });

  importFile.addEventListener("change", async () => {
    const file = importFile.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const backup = JSON.parse(text);
      if (!backup?.state) throw new Error("No state");
      if (!confirm("Import will overwrite the shared campaign state for everyone. Continue?")) { importFile.value=""; return; }

      const state = backup.state;
      await setDoc(stateRef, {
        title: state.title ?? defaults.title,
        linksHtml: state.linksHtml ?? "",
        partyNotesHtml: state.partyNotesHtml ?? "",
        enemyNotesHtml: state.enemyNotesHtml ?? "",
        party: state.party ?? defaults.party,
        enemy: state.enemy ?? defaults.enemy,
        images: state.images ?? defaults.images,
        mapClearVersion: state.mapClearVersion ?? 0,
        updatedAt: serverTimestamp()
      }, { merge: false });

      if (Array.isArray(backup.characters)) {
        for (const c of backup.characters) {
          if (!c.id) continue;
          await setDoc(doc(charsCol, c.id), {
            name: c.name ?? "",
            descHtml: c.descHtml ?? "",
            faction: c.faction ?? "undecided",
            imageUrl: c.imageUrl ?? null,
            createdAt: c.createdAt ?? serverTimestamp(),
            updatedAt: serverTimestamp()
          }, { merge: true });
        }
      }

      alert("Imported (state + characters).");
    } catch (e) {
      console.error(e);
      alert("Import failed. Not a valid backup file.");
    } finally {
      importFile.value = "";
    }
  });

  resetBtn.addEventListener("click", async () => {
    const msg = "Reset shared campaign for everyone?\n\nThis will:\n• reset title/party/enemy/links\n• clear the map drawing\n\nIt will NOT delete Characters Met.";
    if (!confirm(msg)) return;

    await setDoc(stateRef, { ...defaults, updatedAt: serverTimestamp() }, { merge: false });
    await updateDoc(stateRef, { mapClearVersion: increment(1), updatedAt: serverTimestamp() });
    alert("Campaign reset (characters kept).");
  });

  requestAnimationFrame(() => { setCanvasSizeToMatchDisplayed(); redrawAllStrokes(); });
</script>
</body>
</html>
